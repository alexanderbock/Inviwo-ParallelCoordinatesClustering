layout (local_size_variable) in;

layout (binding = 0, offset = 0) uniform atomic_uint memoryAccess;

layout (std430, binding = 1) readonly buffer Values {
    float data[];
} values;

layout (std430, binding = 2) readonly buffer Bins {
    int data[];
} bins;

layout (std430, binding = 3) writeonly buffer OutValues {
    float data[];
} outValues;

uniform int _nBins;
uniform int _nDimensions;

int getBinIndex(float value, const int nBins) {
    const float rangeScaleFactor = (nBins - 1.0) / 2.0;
    return int((value + 1.0) * rangeScaleFactor);
}

bool isBinOccupied(int index, int dimension, const int nBins) {
    return (bins.data[dimension * nBins + index] == 1);
}

float getValue(int id, int dim, const int nDimensions) {
    return values.data[id * nDimensions + dim];
}

void main() {
    // gl_GlobalInvocationID.x \in [0, _nValues / _nDimensions]
    bool isValidDataPoint = true;
    for (int dimension = 0; dimension < _nDimensions; ++dimension) {
        float value = getValue(int(gl_GlobalInvocationID), dimension, _nDimensions);
        int binIndex = getBinIndex(value, _nBins);
        bool isValid = isBinOccupied(binIndex, dimension, _nBins);
        isValidDataPoint = isValidDataPoint && isValid;
    }

    if (isValidDataPoint) {
        int storageLocation = int(atomicCounterIncrement(memoryAccess)) * _nDimensions;
        for (int dimension = 0; dimension < _nDimensions; ++dimension) {
            float value = getValue(int(gl_GlobalInvocationID), dimension, _nDimensions);
            outValues.data[storageLocation + dimension] = value;
        }
    }
}